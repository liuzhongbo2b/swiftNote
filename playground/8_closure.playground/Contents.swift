import UIKit

//闭包（closure）
//闭包的概念很抽象，一般的意义上是指的函数内部的函数，也就是嵌套函数
//一般闭包是一个完整的函数体，相当于其他语言中的代码块，lambda表达式这样子，具有自己完整的功能
//闭包有着桥梁的作用，能起着沟通代码块的作用
//
//闭包的两个前提
//1. 函数能当做参数或者返回值使用
//2. 支持函数嵌套
//
//这里通过改写一下上一章的函数来理解一下闭包
//这是上一章的代码
func calculate(ope: String) -> (Int, Int) -> Int {
    func add(a: Int, b: Int) -> Int {
        return a + b
    }
    func sub(a: Int, b: Int) -> Int {
        return a - b
    }
    
    var result: (Int, Int) -> Int
    switch ope {
    case "+":
        result = add(a:b:)
    case "-":
        result = sub(a:b:)
    default:
        result = add(a:b:)
    }
    return result
}
let f1: (Int, Int) -> Int = calculate(ope: "+")
print("10 + 5 = \(f1(10, 5))")
//
//下面是闭包的写法
func calculate2(ope: String) -> (Int, Int) -> Int {
    var result: (Int, Int) -> Int
    
    switch ope {
    case "+":
        result = {
            (a: Int, b: Int) -> Int in
            return a + b
        }
    case "-":
        result = {
            (a: Int, b: Int) -> Int in
            return a - b
        }
    default:
        result = {
            (a: Int, b: Int) -> Int in
            return a + b
        }
    }
    
    return result
}
let f2: (Int, Int) -> Int = calculate(ope: "+")
print("10 + 5 = \(f2(10, 5))")
//还能这么写,更简单
//{ (a: Int, b: Int) -> Int in return a + b }
//这样的写法，以及上面的，在swift中就是闭包
//
//标准语法是这样的
//      {
//             (参数列表) -> 返回值类型 in
//             语句组
//      }
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//但是由于swift的优秀的类型推断功能，所以可以省略参数的类型，返回值的类型
//像这样
//  {(a, b) in return a + b}
//或者是这样
//  {a, b in return a + b}
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//要是语句组里面只有一条语句，而且这条语句还是返回语句，那么我们就可以省略return
//像这样
//  {a, b in a + b}
//但是有多条语句的时候，这样是不允许的，理由也很简单，程序不会知道哪条语句是返回语句的
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//要是你还是觉得这样不够简单，那么我们还是能够接着省略的--------省略参数列表
//要注意，参数列表和in是要一起省略的
//类似这样
//  { $0 + $1 }
//前面的代表第一个参数，后面的类推
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//其实闭包本质上还是函数类型，只是因为是简单的函数，所以写法很简单，省略了很多东西，闭包是可以直接当成函数来使用的
let c1: Int = { $0 + $1 }(10, 5)
print("c1 = \(c1)")
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//前面说过，函数能够当做函数的参数或者是返回值，那么闭包也是可以的
//但是把一个闭包当做一个函数的参数使用的时候，看起来不是那么清晰，会造成可读性降低
//这里我们就使用“尾随闭包”来使得程序的可读性变高
func calculate3(opr: String, funcName: (Int, Int) -> Int) {
    switch opr {
    case "+":
        print("10 + 5 = \(funcName(10, 5))")
    default:
        print("10 - 5 = \(funcName(10, 5))")
    }
}
//第一种是正常调用，第二三四种是尾随闭包的写法
calculate3(opr: "+", funcName: { (a: Int, b: Int) -> Int in return a + b} )
calculate3(opr: "+") { (a: Int, b: Int) -> Int in return a + b }
calculate3(opr: "+") { $0 + $1 }

calculate3(opr: "-") {
    (a: Int, b: Int) -> Int in
    return a - b
}
//根据上面的例子可以很明显看到，当闭包作为函数参数的时候，写在里面是不容易阅读的
//这时候我们把闭包放在括号外，这样的写法就叫“尾随闭包”
//但是！！！尾随闭包只能当成函数的最后一个参数，这一点很重要
//尾随闭包有时会被误认为函数，但是，看到in，还有$的时候就很明显能分辨了
//
//---------------------------------------------------------------------------------------------------------------------------------------------
//
//闭包的一个很重要的应用就是捕获上下文中的值
//下面有一个例子，可能不是很好理解
func makeArray() -> (String) -> [String] {
    var arr: [String] = [String]()
    
    func addElement(element: String) -> [String] {
        arr.append(element)
        return arr
    }
    return addElement
}

let ff1 = makeArray()
print("----------f1-----------")
print(ff1("张三"))
print(ff1("李四"))
print(ff1("王五"))
//有人想，我是在函数体里面声明的一个数组，为什么在函数体之外这个数组还存在
//但是，addElement函数是在makeArray里面定义的，所以它能够访问上下文里面的内容
//也就是说这个数组对于addElement函数来说，是在一个作用域里面的东西，所以能够调用
//
//将上述代码改成闭包表达式的形式为
func makeArray2() -> (String) -> [String] {
    var arr: [String] = [String]()
    
    return {
        (element: String) -> [String] in
        arr.append(element)
        return arr
    }
}
let ff2 = makeArray2()
print("----------f2-----------")
print(ff2("诸葛亮"))
print(ff2("刘备"))
print(ff2("张飞"))
//可以看到，换成闭包之后，函数简洁了许多
//
//
//注！！！
//闭包在面向协议编程，以及线程队列都有很重要的应用，大家可以多查阅资料学习一下
//关于闭包，在不同的语言中虽然表现形式不同，但是都有着很重要的作用！！
